---
description: 
globs: 
alwaysApply: true
---
# Monitoring & Observability

## Application Performance Monitoring (APM)

### Structured Logging
```csharp
public class PortfolioService
{
    private readonly ILogger<PortfolioService> _logger;
    
    public async Task<decimal> CalculateTimeWeightedReturn(Guid accountId, DateRange period)
    {
        using var activity = Activity.StartActivity("CalculateTWR");
        activity?.SetTag("account.id", accountId.ToString());
        activity?.SetTag("period.start", period.Start.ToString());
        activity?.SetTag("period.end", period.End.ToString());
        
        _logger.LogInformation("Starting TWR calculation for account {AccountId} from {StartDate} to {EndDate}",
            accountId, period.Start, period.End);
            
        var stopwatch = Stopwatch.StartNew();
        
        try
        {
            var result = await PerformCalculation(accountId, period);
            
            _logger.LogInformation("TWR calculation completed for account {AccountId} in {ElapsedMs}ms. Result: {TWR:P4}",
                accountId, stopwatch.ElapsedMilliseconds, result);
                
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "TWR calculation failed for account {AccountId}", accountId);
            throw;
        }
    }
}
```

### Custom Metrics
```csharp
public class PortfolioMetrics
{
    private readonly Counter<int> _calculationCounter;
    private readonly Histogram<double> _calculationDuration;
    private readonly Gauge<int> _activeConnections;
    
    public PortfolioMetrics(IMeterFactory meterFactory)
    {
        var meter = meterFactory.Create("Portfolio.Analytics");
        
        _calculationCounter = meter.CreateCounter<int>(
            "portfolio.calculations.total",
            description: "Total number of portfolio calculations performed");
            
        _calculationDuration = meter.CreateHistogram<double>(
            "portfolio.calculations.duration",
            unit: "ms",
            description: "Duration of portfolio calculations");
            
        _activeConnections = meter.CreateGauge<int>(
            "portfolio.connections.active",
            description: "Number of active database connections");
    }
    
    public void RecordCalculation(string calculationType, double durationMs)
    {
        _calculationCounter.Add(1, new("type", calculationType));
        _calculationDuration.Record(durationMs, new("type", calculationType));
    }
}
```

### Health Checks
```csharp
public class DatabaseHealthCheck : IHealthCheck
{
    private readonly PortfolioContext _context;
    
    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)
    {
        try
        {
            await _context.Database.ExecuteSqlRawAsync("SELECT 1", cancellationToken);
            return HealthCheckResult.Healthy("Database connection is healthy");
        }
        catch (Exception ex)
        {
            return HealthCheckResult.Unhealthy("Database connection failed", ex);
        }
    }
}

public class MarketDataHealthCheck : IHealthCheck
{
    private readonly IMarketDataService _marketDataService;
    
    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)
    {
        try
        {
            var latestPrice = await _marketDataService.GetLatestPrice("AAPL", cancellationToken);
            var dataAge = DateTime.UtcNow - latestPrice.Timestamp;
            
            if (dataAge > TimeSpan.FromHours(24))
                return HealthCheckResult.Degraded($"Market data is {dataAge.TotalHours:F1} hours old");
                
            return HealthCheckResult.Healthy("Market data is current");
        }
        catch (Exception ex)
        {
            return HealthCheckResult.Unhealthy("Market data service unavailable", ex);
        }
    }
}
```

## Error Handling & Alerting

### Global Exception Handler
```csharp
public class GlobalExceptionMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<GlobalExceptionMiddleware> _logger;
    
    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unhandled exception occurred. TraceId: {TraceId}", 
                Activity.Current?.Id ?? context.TraceIdentifier);
                
            await HandleExceptionAsync(context, ex);
        }
    }
    
    private static async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        var response = exception switch
        {
            ValidationException => new { error = "Validation failed", details = exception.Message },
            NotFoundException => new { error = "Resource not found", details = exception.Message },
            UnauthorizedAccessException => new { error = "Access denied" },
            _ => new { error = "An error occurred", traceId = Activity.Current?.Id ?? context.TraceIdentifier }
        };
        
        context.Response.StatusCode = exception switch
        {
            ValidationException => 400,
            NotFoundException => 404,
            UnauthorizedAccessException => 403,
            _ => 500
        };
        
        await context.Response.WriteAsync(JsonSerializer.Serialize(response));
    }
}
```

### Alert Configuration
```yaml
# alerts.yml - Example for Prometheus/Grafana
groups:
  - name: portfolio-alerts
    rules:
      - alert: HighErrorRate
        expr: rate(portfolio_errors_total[5m]) > 0.1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High error rate detected"
          description: "Error rate is {{ $value }} errors per second"
          
      - alert: SlowCalculations
        expr: histogram_quantile(0.95, portfolio_calculations_duration_bucket) > 5000
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "Portfolio calculations are slow"
          description: "95th percentile calculation time is {{ $value }}ms"
          
      - alert: DatabaseDown
        expr: up{job="portfolio-api"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Portfolio API is down"
```

## Performance Monitoring

### Database Query Monitoring
```csharp
public class QueryPerformanceInterceptor : DbCommandInterceptor
{
    private readonly ILogger<QueryPerformanceInterceptor> _logger;
    private readonly IMetrics _metrics;
    
    public override async ValueTask<DbDataReader> ReaderExecutedAsync(
        DbCommand command, 
        CommandExecutedEventData eventData, 
        DbDataReader result,
        CancellationToken cancellationToken = default)
    {
        var duration = eventData.Duration.TotalMilliseconds;
        
        if (duration > 1000) // Log slow queries
        {
            _logger.LogWarning("Slow query detected: {Sql} took {Duration}ms",
                command.CommandText, duration);
        }
        
        _metrics.RecordQueryDuration(duration, command.CommandType.ToString());
        
        return await base.ReaderExecutedAsync(command, eventData, result, cancellationToken);
    }
}
```

### Frontend Performance Monitoring
```typescript
// Performance monitoring for React components
export const usePerformanceMonitor = (componentName: string) => {
  const startTime = useRef<number>();
  
  useEffect(() => {
    startTime.current = performance.now();
    
    return () => {
      if (startTime.current) {
        const duration = performance.now() - startTime.current;
        
        // Send to analytics
        analytics.track('component_render', {
          component: componentName,
          duration,
          timestamp: new Date().toISOString()
        });
        
        // Log slow renders
        if (duration > 100) {
          console.warn(`Slow render detected: ${componentName} took ${duration}ms`);
        }
      }
    };
  }, [componentName]);
};

// Usage in components
const TwrCalculator = ({ accountId }: Props) => {
  usePerformanceMonitor('TwrCalculator');
  
  // Component logic...
};
```

## Business Metrics Dashboard

### Key Performance Indicators
```csharp
public class BusinessMetricsService
{
    public async Task<BusinessMetrics> GetMetrics(DateRange period)
    {
        return new BusinessMetrics
        {
            TotalAssetsUnderManagement = await CalculateAUM(),
            TotalClients = await GetClientCount(),
            CalculationsPerformed = await GetCalculationCount(period),
            AveragePortfolioReturn = await GetAverageReturn(period),
            SystemUptime = GetSystemUptime(),
            DataFreshness = await GetDataFreshness()
        };
    }
}
```

### Custom Dashboards
- **Operations Dashboard**: System health, performance, errors
- **Business Dashboard**: AUM trends, client metrics, calculation volumes  
- **Financial Dashboard**: Return distributions, performance analytics
- **Security Dashboard**: Failed logins, suspicious activity, compliance metrics

## Log Aggregation & Search

### Centralized Logging
```csharp
// Serilog configuration
Log.Logger = new LoggerConfiguration()
    .MinimumLevel.Information()
    .MinimumLevel.Override("Microsoft", LogEventLevel.Warning)
    .Enrich.FromLogContext()
    .Enrich.WithProperty("Application", "PortfolioAnalytics")
    .Enrich.WithProperty("Environment", Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT"))
    .WriteTo.Console(outputTemplate: "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj} {Properties:j}{NewLine}{Exception}")
    .WriteTo.Elasticsearch(new ElasticsearchSinkOptions(new Uri("https://elasticsearch.company.com"))
    {
        AutoRegisterTemplate = true,
        IndexFormat = "portfolio-logs-{0:yyyy.MM.dd}"
    })
    .CreateLogger();
```

### Log Correlation
```csharp
public class CorrelationMiddleware
{
    private readonly RequestDelegate _next;
    
    public async Task InvokeAsync(HttpContext context)
    {
        var correlationId = context.Request.Headers["X-Correlation-ID"].FirstOrDefault() 
                           ?? Guid.NewGuid().ToString();
                           
        context.Items["CorrelationId"] = correlationId;
        context.Response.Headers.Add("X-Correlation-ID", correlationId);
        
        using (LogContext.PushProperty("CorrelationId", correlationId))
        {
            await _next(context);
        }
    }
}
```

## SLA & SLO Monitoring

### Service Level Objectives
- **Availability**: 99.9% uptime (8.76 hours downtime per year)
- **Response Time**: 95th percentile < 500ms for calculations
- **Data Freshness**: Market data < 24 hours old
- **Error Rate**: < 0.1% of requests result in errors

### SLA Dashboards
```typescript
// Example Grafana dashboard query
// Availability SLO
sum(rate(http_requests_total{status!~"5.."}[1h])) / sum(rate(http_requests_total[1h])) * 100

// Response Time SLO  
histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) * 1000
```

