---
description:
globs:
alwaysApply: true
---
# Test-Driven Development Approach

## TDD Cycle for Financial Calculations

### Red-Green-Refactor Pattern
1. **Red**: Write a failing test for the financial calculation
2. **Green**: Write minimal code to make the test pass
3. **Refactor**: Clean up while keeping tests green

### Example: Time Weighted Return TDD

#### Step 1: Red - Write the failing test
```csharp
[Fact]
public void SinglePeriod_NoFlows_equals_simple_return()
{
    var period = new SubPeriod(startValue: 100m, endValue: 110m, netFlow: 0m);
    var twr = _service.TimeWeightedReturn(new[] { period });
    Assert.Equal(0.10m, twr, precision: 4);
}
```

#### Step 2: Green - Minimal implementation
```csharp
public decimal TimeWeightedReturn(IEnumerable<SubPeriod> periods)
{
    return periods.Aggregate(1m, (acc, period) =>
        acc * (1 + (period.EndValue - period.StartValue - period.NetFlow) / period.StartValue)) - 1;
}
```

#### Step 3: Refactor - Add more test cases
```csharp
[Theory]
[InlineData(100, 110, 0, 0.10)]     // Simple return
[InlineData(100, 120, 10, 0.10)]    // With cash inflow
[InlineData(100, 90, -5, 0.05)]     // With cash outflow
public void TimeWeightedReturn_SinglePeriod_ReturnsExpected(
    decimal start, decimal end, decimal flow, decimal expected)
{
    var period = new SubPeriod(start, end, flow);
    var result = _service.TimeWeightedReturn(new[] { period });
    Assert.Equal(expected, result, precision: 4);
}
```

## Test Categories

### Unit Tests (Fast)
- **Domain Logic**: Pure financial calculations without dependencies
- **Validation**: Input validation and business rules
- **Utilities**: Currency conversion, date handling

### Integration Tests (Medium)
- **Database Operations**: EF Core with TestContainers
- **MediatR Handlers**: End-to-end request processing
- **API Endpoints**: Contract testing with WebApplicationFactory

### E2E Tests (Slow)
- **User Workflows**: Critical paths through the UI
- **Data Flow**: Complete scenarios from UI to database
- **Performance**: Load testing for large portfolios

## Testing Tools & Patterns

### Backend (.NET)
```csharp
// xUnit with FluentAssertions
result.Should().BeApproximately(0.1234m, precision: 0.0001m);

// Respawn for database cleanup
await _respawner.ResetAsync(_connectionString);

// TestContainers for real database
var container = new MsSqlBuilder().Build();
```

### Frontend (React)
```typescript
// Vitest with React Testing Library
render(<TwrCalculator accountId="123" />);
expect(screen.getByText('10.5%')).toBeInTheDocument();

// MSW for API mocking
const server = setupServer(
  rest.get('/api/accounts/:id/twr', (req, res, ctx) =>
    res(ctx.json({ twr: 0.105 }))
  )
);
```

## Test Data Strategy

### Builders Pattern
```csharp
public class AccountBuilder
{
    private Account _account = new Account();

    public AccountBuilder WithHolding(string ticker, decimal units)
    {
        _account.Holdings.Add(new Holding { Ticker = ticker, Units = units });
        return this;
    }

    public Account Build() => _account;
}

// Usage in tests
var account = new AccountBuilder()
    .WithHolding("AAPL", 100)
    .WithHolding("GOOGL", 50)
    .Build();
```

### Test Data Factories
- Realistic but predictable market data
- Known currency rates for testing
- Edge cases: market crashes, currency devaluations
- Boundary conditions: zero holdings, negative returns

## Continuous Testing
- Run fast unit tests on every save
- Integration tests on PR creation
- E2E tests on main branch deployment
- Performance benchmarks for financial calculations

