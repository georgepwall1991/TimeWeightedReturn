---
description:
globs:
alwaysApply: true
---
# Backend Architecture (.NET Core) - Enhanced Vertical Slice Design

## Project Structure (Feature-Organized with Subfolders)
```
/src
  /Domain        - Pure C# domain models and business logic
    /Entities    - Core business entities (Client, Portfolio, Account, etc.)
    /Services    - Domain services with business rules
    /ValueObjects - Value objects and enums
    /Exceptions  - Domain-specific exceptions
  /Infrastructure - EF Core, SQL Server, external data providers
    /Data        - DbContext, configurations, migrations
    /Repositories - Data access implementations
    /Services    - External service integrations
  /Application   - MediatR handlers, DTOs, validators (organized by feature slice)
    /Features
      /Portfolio   - Portfolio management vertical slice
        /Queries   - Portfolio queries (GetHoldings, GetTree)
        /Commands  - Portfolio commands (CreatePortfolio, UpdateHoldings)
        /DTOs      - Portfolio-specific data transfer objects
        /Validators - Portfolio validation rules
      /Analytics   - Performance analytics vertical slice
        /Queries   - Analytics queries (CalculateTWR, GetContribution)
        /DTOs      - Analytics DTOs (TwrResult, ContributionData)
        /Services  - Analytics orchestration services
      /Clients     - Client management vertical slice
        /Queries   - Client queries (GetClients, GetClientTree)
        /Commands  - Client commands (CreateClient, UpdateClient)
        /DTOs      - Client DTOs
        /Validators - Client validation rules
      /Common      - Shared cross-cutting concerns
        /Interfaces - Shared service interfaces
        /Behaviors  - MediatR pipeline behaviors
        /DTOs      - Shared DTOs and base classes
        /Extensions - Extension methods
        /Mappings  - AutoMapper profiles
  /Api           - Controllers/Minimal API endpoints
    /Controllers - Feature-based controllers
    /Extensions  - Service registration extensions
    /Middleware  - Custom middleware
/tests
  /Domain.Tests     - Unit tests for business logic
    /Services      - Domain service tests
    /Entities      - Entity behavior tests
  /Application.Tests - Integration tests (organized by feature)
    /Portfolio     - Portfolio feature tests
    /Analytics     - Analytics feature tests
    /Clients       - Client feature tests
  /Api.Tests        - API contract tests
    /Controllers   - Controller integration tests
    /EndToEnd      - Full workflow tests
```

## Vertical Slice Implementation Principles

### 1. Feature Completeness
Each feature slice contains all the layers needed for that specific business capability:
- **Queries**: Read operations for the feature
- **Commands**: Write operations for the feature
- **DTOs**: Data contracts specific to the feature
- **Validators**: Business rule validation
- **Services**: Feature-specific orchestration (if needed)

### 2. Minimal Cross-Feature Dependencies
- Features should be loosely coupled
- Shared code goes in `/Common` or `/Domain`
- Use domain events for cross-feature communication
- Dependency direction: Features → Common → Domain

### 3. Testing Organization
- Tests mirror the source structure
- Feature tests can run independently
- Integration tests focus on feature workflows

## Enhanced MediatR Pattern (Feature-Organized)

### Portfolio Feature Example
```csharp
// Application/Features/Portfolio/Queries/GetHoldings/
public record GetHoldingsQuery(Guid PortfolioId, DateOnly Date) : IRequest<GetHoldingsResponse>;

public class GetHoldingsHandler : IRequestHandler<GetHoldingsQuery, GetHoldingsResponse>
{
    // Handler implementation
}

public class GetHoldingsValidator : AbstractValidator<GetHoldingsQuery>
{
    // Validation rules
}

// Application/Features/Portfolio/DTOs/
public record GetHoldingsResponse(IReadOnlyList<HoldingDto> Holdings, decimal TotalValueGBP);
public record HoldingDto(string Ticker, decimal Units, decimal Price, decimal ValueGBP);
```

### Analytics Feature Example
```csharp
// Application/Features/Analytics/Queries/CalculateTwr/
public record CalculateTwrQuery(Guid AccountId, DateOnly From, DateOnly To) : IRequest<TwrResult>;

public class CalculateTwrHandler : IRequestHandler<CalculateTwrQuery, TwrResult>
{
    private readonly ITimeWeightedReturnService _twrService;
    // Handler implementation with domain service
}

// Application/Features/Analytics/DTOs/
public record TwrResult(decimal TimeWeightedReturn, decimal AnnualizedReturn, IReadOnlyList<SubPeriodDto> SubPeriods);
```

## Core Domain Models (Enhanced)

### Hierarchy Models
```csharp
// Domain/Entities/
public class Client
{
    public Guid Id { get; private set; }
    public string Name { get; private set; } = string.Empty;
    public IReadOnlyList<Portfolio> Portfolios => _portfolios.AsReadOnly();
    private readonly List<Portfolio> _portfolios = new();

    public void AddPortfolio(Portfolio portfolio) { /* business rules */ }
}

public class Portfolio
{
    public Guid Id { get; private set; }
    public Guid ClientId { get; private set; }
    public string Name { get; private set; } = string.Empty;
    public IReadOnlyList<Account> Accounts => _accounts.AsReadOnly();
    private readonly List<Account> _accounts = new();

    public decimal CalculateTotalValue(DateOnly date, ICurrencyConverter converter) { /* business logic */ }
}

public class Account
{
    public Guid Id { get; private set; }
    public Guid PortfolioId { get; private set; }
    public string Name { get; private set; } = string.Empty;
    public Currency Currency { get; private set; } = Currency.GBP;
    public IReadOnlyList<Holding> Holdings => _holdings.AsReadOnly();
    private readonly List<Holding> _holdings = new();

    public void AddHolding(Holding holding) { /* validation and business rules */ }
}
```

### Position & Market Data (Value Objects)
```csharp
// Domain/ValueObjects/
public record Currency(string Code)
{
    public static Currency GBP => new("GBP");
    public static Currency USD => new("USD");
    public static Currency EUR => new("EUR");
}

public record DateRange(DateOnly Start, DateOnly End)
{
    public int Days => End.DayNumber - Start.DayNumber;
    public decimal Years => Days / 365.25m;
}

// Domain/Entities/
public class Holding
{
    public Guid Id { get; private set; }
    public Guid AccountId { get; private set; }
    public Guid InstrumentId { get; private set; }
    public DateOnly Date { get; private set; }
    public decimal Units { get; private set; }
    public Instrument Instrument { get; private set; } = null!;

    public decimal CalculateValue(Price price, FxRate? fxRate = null) { /* business logic */ }
}

public enum InstrumentType { Cash, Equity, Bond, Fund, Derivative }
```

## Enhanced Service Architecture

### Domain Services (Business Logic)
```csharp
// Domain/Services/
public interface ITimeWeightedReturnService
{
    TwrCalculationResult Calculate(IEnumerable<ValuationPoint> valuations, IEnumerable<CashFlow> cashFlows, DateRange period);
}

public interface IContributionAnalysisService
{
    ContributionAnalysisResult Analyze(IEnumerable<Holding> startHoldings, IEnumerable<Holding> endHoldings, DateRange period);
}

public interface ICurrencyConversionService
{
    decimal ConvertToGBP(decimal amount, Currency fromCurrency, DateOnly date);
}
```

### Application Services (Orchestration)
```csharp
// Application/Features/Analytics/Services/
public class PerformanceAnalyticsService
{
    private readonly ITimeWeightedReturnService _twrService;
    private readonly IContributionAnalysisService _contributionService;

    public async Task<ComprehensiveAnalysisResult> AnalyzePerformance(Guid accountId, DateRange period)
    {
        // Orchestrate multiple domain services
        // Handle cross-cutting concerns (caching, logging)
        // Return application-specific DTOs
    }
}
```

## Dependency Injection & Service Registration

### Feature-Based Registration
```csharp
// Api/Extensions/ServiceCollectionExtensions.cs
public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddPortfolioFeatures(this IServiceCollection services)
    {
        services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(typeof(GetHoldingsHandler).Assembly));
        services.AddScoped<IPortfolioRepository, PortfolioRepository>();
        return services;
    }

    public static IServiceCollection AddAnalyticsFeatures(this IServiceCollection services)
    {
        services.AddScoped<ITimeWeightedReturnService, TimeWeightedReturnService>();
        services.AddScoped<IContributionAnalysisService, ContributionAnalysisService>();
        return services;
    }

    public static IServiceCollection AddApplicationFeatures(this IServiceCollection services)
    {
        return services
            .AddPortfolioFeatures()
            .AddAnalyticsFeatures()
            .AddClientFeatures()
            .AddCommonServices();
    }
}
```

### Program.cs Configuration
```csharp
// Clean, organized service registration
builder.Services.AddApplicationFeatures();
builder.Services.AddInfrastructureServices(builder.Configuration);
builder.Services.AddApiServices();
```

## API Organization

### Feature-Based Controllers
```csharp
// Api/Controllers/PortfolioController.cs
[ApiController]
[Route("api/[controller]")]
public class PortfolioController : ControllerBase
{
    private readonly IMediator _mediator;

    [HttpGet("{id}/holdings")]
    public async Task<ActionResult<GetHoldingsResponse>> GetHoldings(
        Guid id,
        [FromQuery] DateOnly date,
        CancellationToken cancellationToken)
    {
        var query = new GetHoldingsQuery(id, date);
        var result = await _mediator.Send(query, cancellationToken);
        return Ok(result);
    }
}

// Api/Controllers/AnalyticsController.cs
[ApiController]
[Route("api/analytics")]
public class AnalyticsController : ControllerBase
{
    [HttpGet("accounts/{accountId}/twr")]
    public async Task<ActionResult<TwrResult>> CalculateTimeWeightedReturn(
        Guid accountId,
        [FromQuery] DateOnly from,
        [FromQuery] DateOnly to,
        CancellationToken cancellationToken)
    {
        var query = new CalculateTwrQuery(accountId, from, to);
        var result = await _mediator.Send(query, cancellationToken);
        return Ok(result);
    }
}
```

## Enhanced Testing Strategy

### Feature-Focused Tests
```csharp
// tests/Application.Tests/Portfolio/GetHoldingsHandlerTests.cs
public class GetHoldingsHandlerTests : IClassFixture<DatabaseFixture>
{
    [Fact]
    public async Task GetHoldings_WithValidPortfolio_ReturnsHoldingsWithCorrectValues()
    {
        // Arrange - feature-specific test data
        // Act - test the complete feature workflow
        // Assert - verify business outcomes
    }
}

// tests/Application.Tests/Analytics/CalculateTwrHandlerTests.cs
public class CalculateTwrHandlerTests
{
    [Theory]
    [MemberData(nameof(TwrTestCases))]
    public async Task CalculateTwr_VariousScenarios_ReturnsCorrectResults(TwrTestCase testCase)
    {
        // Test financial calculation accuracy
    }
}
```

## Development Database Setup (Enhanced)
```csharp
// Infrastructure/Data/PortfolioContextFactory.cs
public class PortfolioContextFactory : IDesignTimeDbContextFactory<PortfolioContext>
{
    public PortfolioContext CreateDbContext(string[] args)
    {
        var optionsBuilder = new DbContextOptionsBuilder<PortfolioContext>();
        optionsBuilder.UseSqlServer("Server=(localdb)\\MSSQLLocalDB;Database=PerformanceCalculationDb;Trusted_Connection=true;MultipleActiveResultSets=true");
        return new PortfolioContext(optionsBuilder.Options);
    }
}

// Program.cs
if (builder.Environment.IsDevelopment())
{
    builder.Services.AddDbContext<PortfolioContext>(options =>
        options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection"))
               .EnableSensitiveDataLogging()
               .EnableDetailedErrors());
}
```

## Migration & Development Commands
```bash
# Feature-specific migrations
dotnet ef migrations add Portfolio_InitialCreate --project src/Infrastructure
dotnet ef migrations add Analytics_AddCashFlows --project src/Infrastructure

# Database operations
dotnet ef database update --project src/Infrastructure
dotnet ef database drop --force --project src/Infrastructure

# Run feature-specific tests
dotnet test tests/Application.Tests/Portfolio/
dotnet test tests/Application.Tests/Analytics/

# Verify database schema
sqlcmd -S "(localdb)\MSSQLLocalDB" -Q "SELECT name FROM sys.databases WHERE name = 'PerformanceCalculationDb'"
```

## Best Practices Summary

### 1. **Vertical Slice Cohesion**
- Each feature folder contains everything needed for that business capability
- Minimize dependencies between features
- Use shared/common code judiciously

### 2. **Clear Separation of Concerns**
- Domain: Pure business logic, no framework dependencies
- Application: Orchestration, DTOs, validation
- Infrastructure: Data access, external services
- API: HTTP concerns, routing, serialization

### 3. **Testability**
- Features can be tested in isolation
- Clear boundaries enable focused testing
- Business logic testable without infrastructure

### 4. **Maintainability**
- Feature changes are localized
- Easy to add new features without affecting existing ones

- Clear code organization improves developer productivity

