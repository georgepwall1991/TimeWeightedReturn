---
description: 
globs: 
alwaysApply: true
---
# Performance & Scalability

## Database Performance Optimization

### Query Optimization Patterns
```csharp
public class OptimizedPortfolioRepository
{
    // Use compiled queries for frequently executed operations
    private static readonly Func<PortfolioContext, Guid, DateOnly, IEnumerable<Holding>> 
        GetHoldingsByAccountAndDate = EF.CompileQuery(
            (PortfolioContext context, Guid accountId, DateOnly date) =>
                context.Holdings
                    .Where(h => h.AccountId == accountId && h.Date == date)
                    .Include(h => h.Instrument)
                    .AsNoTracking());

    // Batch operations to reduce database roundtrips
    public async Task<Dictionary<Guid, decimal>> GetPortfolioValues(
        IEnumerable<Guid> accountIds, 
        DateOnly date)
    {
        var holdings = await _context.Holdings
            .Where(h => accountIds.Contains(h.AccountId) && h.Date == date)
            .Include(h => h.Instrument)
            .ThenInclude(i => i.Prices.Where(p => p.Date == date))
            .AsNoTracking()
            .ToListAsync();

        return holdings
            .GroupBy(h => h.AccountId)
            .ToDictionary(
                g => g.Key,
                g => g.Sum(h => h.Units * h.Instrument.Prices.First().Price));
    }

    // Use raw SQL for complex aggregations
    public async Task<IEnumerable<PerformanceMetric>> GetPerformanceMetrics(
        Guid portfolioId, 
        DateRange period)
    {
        var sql = @"
            WITH daily_values AS (
                SELECT 
                    h.AccountId,
                    h.Date,
                    SUM(h.Units * p.Price * ISNULL(fx.Rate, 1)) as ValueGBP
                FROM Holdings h
                INNER JOIN Prices p ON h.InstrumentId = p.InstrumentId AND h.Date = p.Date
                INNER JOIN Instruments i ON h.InstrumentId = i.Id
                LEFT JOIN FxRates fx ON i.Currency = fx.QuoteCurrency AND h.Date = fx.Date
                WHERE h.AccountId IN (
                    SELECT Id FROM Accounts WHERE PortfolioId = @portfolioId
                )
                AND h.Date BETWEEN @startDate AND @endDate
                GROUP BY h.AccountId, h.Date
            )
            SELECT 
                AccountId,
                MIN(ValueGBP) as MinValue,
                MAX(ValueGBP) as MaxValue,
                AVG(ValueGBP) as AvgValue,
                (MAX(ValueGBP) - MIN(ValueGBP)) / MIN(ValueGBP) as TotalReturn
            FROM daily_values
            GROUP BY AccountId";

        return await _context.Database
            .SqlQueryRaw<PerformanceMetric>(sql, 
                new SqlParameter("@portfolioId", portfolioId),
                new SqlParameter("@startDate", period.Start),
                new SqlParameter("@endDate", period.End))
            .ToListAsync();
    }
}
```

### Caching Strategy
```csharp
public class CachedCalculationService
{
    private readonly IMemoryCache _cache;
    private readonly IDistributedCache _distributedCache;
    private readonly TimeWeightedReturnService _twrService;

    public async Task<decimal> CalculateTimeWeightedReturn(
        Guid accountId, 
        DateRange period)
    {
        var cacheKey = $"twr:{accountId}:{period.Start}:{period.End}";
        
        // Try L1 cache (in-memory)
        if (_cache.TryGetValue(cacheKey, out decimal cachedResult))
        {
            return cachedResult;
        }

        // Try L2 cache (distributed)
        var distributedResult = await _distributedCache.GetStringAsync(cacheKey);
        if (distributedResult != null)
        {
            var result = decimal.Parse(distributedResult);
            _cache.Set(cacheKey, result, TimeSpan.FromMinutes(5));
            return result;
        }

        // Calculate and cache
        var twr = await _twrService.Calculate(accountId, period);
        
        // Cache for 1 hour in distributed cache
        await _distributedCache.SetStringAsync(
            cacheKey, 
            twr.ToString(), 
            new DistributedCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = TimeSpan.FromHours(1)
            });

        // Cache for 5 minutes in memory
        _cache.Set(cacheKey, twr, TimeSpan.FromMinutes(5));
        
        return twr;
    }
}
```

### Connection Pooling & Database Optimization
```csharp
// Startup.cs / Program.cs
services.AddDbContext<PortfolioContext>(options =>
{
    options.UseSqlServer(connectionString, sqlOptions =>
    {
        sqlOptions.CommandTimeout(30);
        sqlOptions.EnableRetryOnFailure(
            maxRetryCount: 3,
            maxRetryDelay: TimeSpan.FromSeconds(10),
            errorNumbersToAdd: null);
    });
    
    // Disable change tracking for read-only queries
    options.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
});

// Connection pooling configuration
services.AddPooledDbContextFactory<PortfolioContext>(options =>
    options.UseSqlServer(connectionString), poolSize: 128);
```

## Application-Level Performance

### Asynchronous Processing
```csharp
public class BackgroundCalculationService : BackgroundService
{
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<BackgroundCalculationService> _logger;
    private readonly Channel<CalculationRequest> _channel;

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        await foreach (var request in _channel.Reader.ReadAllAsync(stoppingToken))
        {
            using var scope = _serviceProvider.CreateScope();
            var calculator = scope.ServiceProvider.GetRequiredService<ICalculationService>();
            
            try
            {
                await calculator.ProcessRequest(request);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to process calculation request {RequestId}", 
                    request.Id);
            }
        }
    }

    public async Task QueueCalculation(CalculationRequest request)
    {
        await _channel.Writer.WriteAsync(request);
    }
}

// Usage in API controller
[HttpPost("calculate-async")]
public async Task<IActionResult> CalculateAsync(CalculationRequest request)
{
    await _backgroundService.QueueCalculation(request);
    return Accepted(new { RequestId = request.Id, Status = "Queued" });
}
```

### Parallel Processing
```csharp
public class ParallelCalculationService
{
    public async Task<Dictionary<Guid, decimal>> CalculateMultipleReturns(
        IEnumerable<Guid> accountIds, 
        DateRange period)
    {
        var semaphore = new SemaphoreSlim(Environment.ProcessorCount);
        var tasks = accountIds.Select(async accountId =>
        {
            await semaphore.WaitAsync();
            try
            {
                var twr = await CalculateTimeWeightedReturn(accountId, period);
                return new { AccountId = accountId, TWR = twr };
            }
            finally
            {
                semaphore.Release();
            }
        });

        var results = await Task.WhenAll(tasks);
        return results.ToDictionary(r => r.AccountId, r => r.TWR);
    }

    // Use Parallel.ForEach for CPU-bound operations
    public decimal[] CalculateReturns(decimal[] values, decimal[] flows)
    {
        var results = new decimal[values.Length];
        
        Parallel.For(0, values.Length, new ParallelOptions
        {
            MaxDegreeOfParallelism = Environment.ProcessorCount
        }, i =>
        {
            results[i] = (values[i] - flows[i]) / values[i];
        });
        
        return results;
    }
}
```

## Frontend Performance

### Virtual Scrolling for Large Datasets
```typescript
import { FixedSizeList as List } from 'react-window';

interface VirtualizedTableProps {
  holdings: Holding[];
  height: number;
}

const VirtualizedTable: React.FC<VirtualizedTableProps> = ({ holdings, height }) => {
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => {
    const holding = holdings[index];
    
    return (
      <div style={style} className="table-row">
        <span>{holding.ticker}</span>
        <span>{formatCurrency(holding.value)}</span>
        <span>{formatPercentage(holding.return)}</span>
      </div>
    );
  };

  return (
    <List
      height={height}
      itemCount={holdings.length}
      itemSize={50}
      overscanCount={10}
    >
      {Row}
    </List>
  );
};
```

### Optimized State Management
```typescript
// Use RTK Query with aggressive caching
export const portfolioApi = createApi({
  reducerPath: 'portfolioApi',
  baseQuery: fetchBaseQuery({
    baseUrl: '/api',
    prepareHeaders: (headers, { getState }) => {
      headers.set('x-correlation-id', generateCorrelationId());
      return headers;
    },
  }),
  tagTypes: ['Portfolio', 'Holdings', 'Calculations'],
  endpoints: (builder) => ({
    getPortfolioTree: builder.query<PortfolioTree, { clientId: string }>({
      query: ({ clientId }) => `clients/${clientId}/tree`,
      providesTags: ['Portfolio'],
      // Cache for 5 minutes
      keepUnusedDataFor: 300,
    }),
    
    calculateTWR: builder.query<TWRResult, TWRRequest>({
      query: (params) => ({
        url: `accounts/${params.accountId}/twr`,
        params: { from: params.from, to: params.to },
      }),
      providesTags: ['Calculations'],
      // Cache calculations for 1 hour
      keepUnusedDataFor: 3600,
    }),
  }),
});

// Memoized selectors for derived state
export const selectPortfolioMetrics = createSelector(
  [selectPortfolioTree, selectCalculations],
  (tree, calculations) => {
    // Heavy computation here is memoized
    return tree.map(node => ({
      ...node,
      metrics: calculations[node.id] || null
    }));
  }
);
```

### Code Splitting & Lazy Loading
```typescript
// Route-based code splitting
const PortfolioAnalytics = lazy(() => import('./pages/PortfolioAnalytics'));
const TwrAnalysis = lazy(() => import('./pages/TwrAnalysis'));
const Attribution = lazy(() => import('./pages/Attribution'));

function App() {
  return (
    <Router>
      <Suspense fallback={<LoadingSpinner />}>
        <Routes>
          <Route path="/portfolio/*" element={<PortfolioAnalytics />} />
          <Route path="/twr/*" element={<TwrAnalysis />} />
          <Route path="/attribution/*" element={<Attribution />} />
        </Routes>
      </Suspense>
    </Router>
  );
}

// Component-level lazy loading
const HeavyChart = lazy(() => 
  import('./components/HeavyChart').then(module => ({
    default: module.HeavyChart
  }))
);
```

## Horizontal Scaling

### Load Balancing Configuration
```nginx
# nginx.conf
upstream portfolio_api {
    least_conn;
    server portfolio-api-1:8080 max_fails=3 fail_timeout=30s;
    server portfolio-api-2:8080 max_fails=3 fail_timeout=30s;
    server portfolio-api-3:8080 max_fails=3 fail_timeout=30s;
}

server {
    listen 80;
    server_name portfolio.company.com;

    location /api/ {
        proxy_pass http://portfolio_api;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Enable response caching
        proxy_cache api_cache;
        proxy_cache_valid 200 5m;
        proxy_cache_use_stale error timeout http_500 http_502 http_503 http_504;
    }
}
```

### Auto-scaling Configuration
```yaml
# kubernetes/hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: portfolio-api-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: portfolio-api
  minReplicas: 3
  maxReplicas: 20
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  - type: Pods
    pods:
      metric:
        name: requests_per_second
      target:
        type: AverageValue
        averageValue: "100"
```

## Database Scaling

### Read Replicas & CQRS
```csharp
public class ReadOnlyPortfolioContext : DbContext
{
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(_readReplicaConnectionString);
        optionsBuilder.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
    }
}

public class PortfolioQueryService
{
    private readonly ReadOnlyPortfolioContext _readContext;
    
    // All queries go to read replica
    public async Task<IEnumerable<Portfolio>> GetPortfolios(Guid clientId)
    {
        return await _readContext.Portfolios
            .Where(p => p.ClientId == clientId)
            .AsNoTracking()
            .ToListAsync();
    }
}

public class PortfolioCommandService
{
    private readonly PortfolioContext _writeContext;
    
    // All commands go to primary database
    public async Task CreatePortfolio(Portfolio portfolio)
    {
        _writeContext.Portfolios.Add(portfolio);
        await _writeContext.SaveChangesAsync();
    }
}
```

### Database Partitioning
```sql
-- Partition holdings table by date for better performance
CREATE PARTITION FUNCTION HoldingsDatePartition (DATE)
AS RANGE RIGHT FOR VALUES 
    ('2023-01-01', '2023-02-01', '2023-03-01', '2023-04-01', 
     '2023-05-01', '2023-06-01', '2023-07-01', '2023-08-01',
     '2023-09-01', '2023-10-01', '2023-11-01', '2023-12-01');

CREATE PARTITION SCHEME HoldingsDateScheme
AS PARTITION HoldingsDatePartition
ALL TO ([PRIMARY]);

CREATE TABLE Holdings (
    Id UNIQUEIDENTIFIER NOT NULL,
    AccountId UNIQUEIDENTIFIER NOT NULL,
    InstrumentId UNIQUEIDENTIFIER NOT NULL,
    Date DATE NOT NULL,
    Units DECIMAL(18,6) NOT NULL,
    CreatedAt DATETIME2 NOT NULL,
    CONSTRAINT PK_Holdings PRIMARY KEY (Id, Date)
) ON HoldingsDateScheme(Date);
```

## Performance Monitoring & Tuning

### Custom Performance Counters
```csharp
public class PerformanceCounters
{
    private readonly Counter<int> _calculationsPerSecond;
    private readonly Histogram<double> _databaseQueryDuration;
    private readonly Gauge<long> _memoryUsage;

    public void RecordCalculation()
    {
        _calculationsPerSecond.Add(1);
    }

    public void RecordQueryDuration(double milliseconds)
    {
        _databaseQueryDuration.Record(milliseconds);
    }

    public void UpdateMemoryUsage()
    {
        var memory = GC.GetTotalMemory(false);
        _memoryUsage.Record(memory);
    }
}
```

### Performance Testing
```csharp
[Fact]
public async Task CalculateTWR_Performance_Test()
{
    // Arrange
    var accountIds = Enumerable.Range(1, 1000)
        .Select(_ => Guid.NewGuid())
        .ToList();
    
    var stopwatch = Stopwatch.StartNew();
    
    // Act
    var results = await _service.CalculateMultipleReturns(
        accountIds, 
        new DateRange(new DateOnly(2023, 1, 1), new DateOnly(2023, 12, 31)));
    
    stopwatch.Stop();
    
    // Assert
    results.Should().HaveCount(1000);
    stopwatch.ElapsedMilliseconds.Should().BeLessThan(5000); // 5 second SLA
}
```

